<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Aesthetic of Electronic-Music Performance Practice Graph</title>
    <link rel="stylesheet" href="./style.css">
    <link rel="icon" href="./favicon.ico" type="image/x-icon">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js" integrity="sha512-8RnEqURPUc5aqFEN04aQEiPlSAdE0jlFS/9iGgUyNtwFnSKCXhmB6ZTNl7LnDtDWKabJIASzXrzD0K+LYexU9g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css" integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js" integrity="sha512-I6CdJdruzGtvDyvdO4YsiAq+pkWf2efgd1ZUSK2FnM/u2VuRASPC7GowWQrWyjxCZn6CT89s3ddGI+be0Ak9Fg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
 -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.js"></script>
    <script>

        const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');

        const state = {
            settings: {
                elasticity: 0.5,
                showVisualMedia: true,
                showKnowledge: true,
                darkMode: false
            },
            values: {},
            longProperty: "hopefully no linebreak :)",
            visualMediaAngle: 0.3
        }
        const ARROW_SIZE = 10;
        let center;
        let vPre, vEmb, vTra, vDeg, vSpa, vMed, vCam, vBod; // TODO: don't need these references I guess
        let vWorKno, vCulKno;
        let dims = [];
        let visArrow;
        let cursor = 'auto';
        let selection = null;
        let canvasWithoutKnowledge;

        let NO_SELECTION;
        const GRAB_DISTANCE = 30;

        const GRABBABLE_OBJECTS = [];

        class Grabbable {
            constructor(position) {
                this.position = position;
                this.hover = false;
                GRABBABLE_OBJECTS.push(this);
            }

            update() {
                this.hover = false;

                const d = dist(mouseX, mouseY, this.position.x, this.position.y);
                if (d < GRAB_DISTANCE) {
                    cursor = 'grab';

                    if (selection == null || d < dist(mouseX, mouseY, selection.position.x, selection.position.y)) {
                        selection.hover = false;
                        selection = this;
                        this.hover = true;
                    }
                }
            }
            grab() { }
        }

        class VisualMediaArrow extends Grabbable {
            constructor() {
                super(createVector(0, 0));
                this.angle = state.visualMediaAngle;
            }
            draw() {
                const avv = createVector(height / 2 - 20, 0)
                    .rotate(this.angle)
                    .add(center);
                stroke(255, 0, 0);
                this.position.x = avv.x;
                this.position.y = avv.y;
                const clr = this.hover ? color('red') : color('darkred');
                arrow(avv.x, avv.y, center.x, center.y, clr);
                //if (av < 0) { 
                const avvText = avv.copy()
                    .sub(center)
                    .mult(1.01)
                    .add(center);

                const offset = createVector(lerp(50, -50, avv.x / width), 0);
                if (this.angle > 0) {
                    offset.y = lerp(25, 12, constrain((avv.y - 400) / 380, 0, 1));

                } else {
                    offset.y = lerp(0, -15, constrain((avv.y - 20) / 100, 0, 1))

                }
                avvText.add(offset);
                // print(avv.y);
                textAlign(CENTER);

                text("visual media", avvText.x, avvText.y);
            }
            grab() {

                const mouse = createVector(mouseX, mouseY);
                this.angle = mouse.sub(center).heading();
                state.visualMediaAngle = round(this.angle, 3);
            }
        }

        class Dim extends Grabbable {
            constructor(x, y, origin, id) {
                super(createVector(lerp(x, origin.x, 0.5),
                    lerp(y, origin.y, 0.5)));
                this.x = x;
                this.y = y;
                this.id = id;
                if (state.values[this.id]) {
                    this.val = state.values[this.id];
                } else {
                    this.val = random();
                    state.values[this.id] = round(this.val, 3);
                }
                this.pos = this.position;
                this.origin = origin;
            }
            draw() {
                
                //this.val = constrain(this.val + ((random()*0.02)-0.01),0.0,1.0);
                this.pos.x = lerp(this.origin.x, this.x, this.val * 0.95);
                this.pos.y = lerp(this.origin.y, this.y, this.val * 0.95);
                arrow(this.x, this.y, this.origin.x, this.origin.y);
                
                stroke(200);
                strokeWeight(20);
                if (this.hover) {
                    stroke(200, 0, 0);
                }
                point(this.pos.x, this.pos.y);
                strokeWeight(1);
                stroke(0);


            }
            drawCurve() {
                curveVertex(this.pos.x, this.pos.y);
            }
            grab() {
                let b = dist(this.x, this.y, mouseX, mouseY);
                let a = dist(this.origin.x, this.origin.y, mouseX, mouseY);
                this.val = constrain(a / (a + b), 0, 1);
                state.values[this.id] = round(this.val, 3);
            }
        }

        function copyProperties(obj1, obj2) {
            Object.keys(obj2).forEach(function (key) {
                if (key in obj1) {
                    if (typeof obj1[key] === 'object') {
                        copyProperties(obj1[key], obj2[key]);
                    } else {
                        obj1[key] = obj2[key];
                    }
                }
            });
        };

        /*  function pasteState() {
            let clipText = '{}';
            // try {
            //     const result = await navigator.permissions.query({ name: "clipboard-read" });
            //     if (result.state === "granted" || result.state === "prompt") {
            //         clipText = await navigator.clipboard.readText();
            //     }
            // } catch (error) {
                let pasteText = document.querySelector("#paste-output");
                pasteText.focus();
                pasteText.textContent = "";
                document.execCommand("paste");
                clipText = pasteText.textContent;
                console.log(pasteText);
            // }
            console.log(clipText);
            const newState = JSON.parse(clipText);
            copyProperties(state, newState);
            setup();
        
        }
        function copyState() {
        
        } */


        function setup() {
            createCanvas(1000, 800, document.getElementById('sketch-canvas'));
            canvasWithoutKnowledge = createGraphics(800, 800);
            textFont('Gabarito');
            textStyle(BOLD);

            // clear list of registered grabbable objects
            GRABBABLE_OBJECTS.splice(0, GRABBABLE_OBJECTS.length);

            center = createVector(600, height / 2);
            visArrow = new VisualMediaArrow();
            NO_SELECTION = new Grabbable(createVector(-1000, -1000));


            //arrow(20,400,780,400);
            //arrow(400,20,400,780);
            //arrow(120,120,680,680);
            //arrow(120,680,680,120);

            vPre = new Dim(400, 20, center, "presence");
            vEmb = new Dim(680, 120, center, "embodiment");
            vTra = new Dim(780, 400, center, "trasparency");
            vDeg = new Dim(680, 680, center, "freedom");
            vSpa = new Dim(400, 780, center, "space");
            vMed = new Dim(120, 680, center, "mediation");
            vCam = new Dim(20, 400, center, "camouflage");
            vBod = new Dim(120, 120, center, "body");
            dims = [vPre, vEmb, vTra, vDeg, vSpa, vMed, vCam, vBod];


            dims.forEach(d => {
                d.x += 200;

            });

            const positionOfKnowledge = 120;
            const originOfKnowledge = createVector(120, height / 2);
            vCulKno = new Dim(originOfKnowledge.x, height - 20, originOfKnowledge, "culturalKnowledge");
            vWorKno = new Dim(originOfKnowledge.x, 20, originOfKnowledge, "workbasedKnowledge");

        }

        function arrow(a, b, c, d, col) {
            col = col || (state.settings.darkMode ? 255 : 0);
            strokeWeight(4);
            let v = createVector(a - c, b - d)
                .normalize()
                .mult(ARROW_SIZE);
            let n = createVector(a - c, b - d)
                .normalize()
                .rotate(PI * 1.5)
                .mult(ARROW_SIZE * 0.5);
            stroke(col);
            fill(col);
            line(a, b, c, d);
            triangle(a, b, a + n.x - v.x, b + n.y - v.y, a - n.x - v.x, b - n.y - v.y);
            //triangle(c,d,c+n.x+v.x,d+n.y+v.y,c-n.x+v.x,d-n.y+v.y);
            strokeWeight(0);

        }

        function drawArrow(v) {
            arrow(v.x, v.y, center.x, center.y);
        }

        function drawKnowledge() {
            //arrow(position,20,position,height/2);
            //arrow(position,height-20,position,height/2);

            textAlign(CENTER);
            fill((state.settings.darkMode ? 255 : 0));
            stroke((state.settings.darkMode ? 100 : 0));
            strokeWeight(0);
            text("work based knowledge required", vCulKno.origin.x+5, 15);
            text("cultural knowledge required", vCulKno.origin.x, height - 5);

            strokeWeight(1);
            fill(100, 100, 100, 40);
            curveTightness(0.1);
            beginShape();
            const knoShapeWidth = 15;
            curveVertex(vCulKno.origin.x - knoShapeWidth, vWorKno.origin.y);
            vWorKno.drawCurve();
            curveVertex(vWorKno.origin.x + knoShapeWidth, vWorKno.origin.y);
            vCulKno.drawCurve();
            curveVertex(vCulKno.origin.x - knoShapeWidth, vWorKno.origin.y);
            vWorKno.drawCurve();
            curveVertex(vWorKno.origin.x + knoShapeWidth, vWorKno.origin.y);
            endShape();

            
            vCulKno.draw();
            vWorKno.draw();
            strokeWeight(4);
            stroke((state.settings.darkMode ? 255 : 0));
            line(vCulKno.origin.x - 20, vCulKno.origin.y,
                vCulKno.origin.x + 20, vCulKno.origin.y);
        }

        function resetState() {
            cursor = 'auto';
            if (!mouseIsPressed) {
                selection = NO_SELECTION;
                GRABBABLE_OBJECTS.forEach(o => o.update());
            }
        }

        function draw() {
            resetState();
            if (state.settings.darkMode) {
                background(0);
            } else {
                background(240);
            }

            if (state.settings.showKnowledge) {
                drawKnowledge();
            }

            if (state.settings.showVisualMedia) {
                visArrow.draw();
            }

            
            fill(100, 100, 100, 40);
            stroke((state.settings.darkMode ? 100 : 0));
            curveTightness(state.settings.elasticity);
            strokeWeight(1);
            beginShape();
            dims.forEach(d => {
                d.drawCurve();
            });
            dims[0].drawCurve();
            dims[1].drawCurve();
            dims[2].drawCurve();
            endShape();

            //stroke(255, 0, 255);
            dims.forEach(d => {
                d.draw();
            });


            //}

            translate(200, 0);
            textSize(18);
            strokeWeight(0);
            stroke((state.settings.darkMode ? 255 : 0));
            fill((state.settings.darkMode ? 255 : 0));
            textAlign(CENTER);
            drawText("space", 400, 795, "(centered/expanded)");
            drawText("Mediatization", 120, 710);
            drawText("Body", 120, 105);
            drawText("Presence", 400, 15);
            drawText("Embodiment", 680, 105);
            textAlign(LEFT);
            drawText("Camouflage", 15, 380);
            textAlign(RIGHT);
            drawText("Transparency", 785, 380);
            drawText("degrees of freedom", 705, 710, "(many/few)");
            translate(-200, 0);




            document.getElementById("sketch-canvas").style.cursor = cursor;
        }

        
        function drawText(textContent,x,y,additionalText) {
            const align = textAlign().horizontal;
            
            strokeWeight(0);
            textStyle(BOLD);
            if (!isFirefox) {
                // so text rendering seems to be a bit different for each browser...
                // non-firefox browser use a pretty tight spacing so we add a single
                // small-ish in between each character to give em some breating room.
                text(addLetterSpacing(textContent.toLowerCase(),1, '\u2009'),x,y);
            } else {
                text(textContent.toLowerCase(),x,y);
            }

            if (additionalText) {
                let tWidth = textWidth(textContent);
                if (align == CENTER) {
                    tWidth /= 2;
                } else if (align == RIGHT) {
                    tWidth = 0;
                }
                textAlign(LEFT);
                textStyle(NORMAL);
                text(additionalText,x+tWidth+4,y);
                textAlign(align);
            }
            
        }




        // adds spacing between letters in a string by
        // inserting blank characters between each letter
        function addLetterSpacing(input, amount, spacer) {
        
        // 'spacer' character to use
        // (can be passed in as an optional argument, or it
        // will use the unicode 'hair space' one by default)
        spacerCharacter = '\u200A' || spacer;
        
        // split the string into a list of characters
        let characters = input.split('');
        
        // create a series of spacers using the
        // repeat() function
        spacerCharacter = spacerCharacter.repeat(amount);
        
        // use join() to combine characters with the spacer
        // and send back as a string
        return characters.join(spacerCharacter);
        }

        function mouseDragged() {
            selection.grab();
            let nn = dims[0];
            let minDist = width;
            //print(av);

            /*
            dims.forEach(d => {
              let distance = dist(d.pos.x,d.pos.y,mouseX,mouseY);
              if (distance < minDist) {
                nn = d;
                minDist = distance;
              }
            });
            if (minDist < 50) {
              
              fill(0,0,255); 
              ellipse(nn.pos.x, nn.pos.y, 50, 50); 
              let a = dist(nn.x,nn.y,mouseX,mouseY);
              let b = dist(center.x,center.y,mouseX,mouseY);
              nn.val = constrain(a / (a+b),0,1);
            }
            */
            // prevent default
            return false;
        }


    </script>
    <!--
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/styles/base16/circus.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
-->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400;500&display=swap" rel="stylesheet">


    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">


    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .help-text {
            font-size: 0.8em;
  color: #666;
  text-align: justify;
            padding: 0.5em 0em;
        }

        :root {
            --mdc-theme-primary: black;
            --mdc-theme-secondary: darkred;
            --mdc-switch-selected-track-color: #aaa;
            --mdc-switch-unselected-hover-track-color: #fff;
            --mdc-switch-selected-hover-track-color: #fff;
        }
.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label {
    color:#999;
}

        :root .dark {
            --mdc-theme-primary: white;
            --mdc-theme-secondary: darkred;
            --mdc-switch-selected-track-color: #aaa;
            --mdc-switch-unselected-hover-track-color: #ddd;
            --mdc-switch-selected-hover-track-color: #ddd;   
            --mdc-theme-surface: #111;
            --mdc-theme-on-primary: #000;
}
.dark .mdc-text-field,
.dark .mdc-text-field .mdc-text-field__input,
.dark .mdc-text-field--filled {
    background-color: #1A1A1A;
    color: white;
}
.dark .mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label {
    color: #888;
}

        body,
        main {
            min-width: 100vw;
            min-height: 100vh;
            font-family: 'Gabarito', sans-serif;
            background-color: rgb(240, 240, 240);
        }

        body.dark,
        .dark main {
            background-color: black;
            color: white;
        }

#copy-link-btn {
    position: absolute;
  right: 2px;
  bottom: 12px;
  background-color: white;
  min-width: 10px;
}
.dark #copy-link-btn {
    background-color: #1A1A1A;
}

        main {
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }

        h1 {
            font-weight: normal;
            text-align: center;
            margin: 1em 2em;
        }

        #content {
            display: flex;
            justify-content: center;
            flex-wrap: wrap-reverse;
        }

        #controls {
            font-weight: normal;
            min-width: 200px;
        }

        .mdc-drawer {
            padding: 1em;
            min-width: 300px;
        }

        .mdc-drawer__content>div {
            margin: 2em 1.5em;
        }

        #sketch {
            min-width: 1000px;
        }

        code {
            border: 1px solid darkgray;
            border-radius: 4px;
            margin: 1em 0;
        }

        #elasticity-slider {
            margin: 0;
        }
        hr {
            border: 1px solid #DDD;
        }
        .dark hr {
            border: 1px solid #222;
        }
        #citation {
            font-size: 0.7em;
            color:#AAA;
            padding: 3em;
            font-style: italic;
            text-align: center;
        }
    </style>


</head>

<body class="dark">

    <aside class="mdc-drawer mdc-drawer--modal">
        <div class="mdc-drawer__content">



            <div style="margin-top: 0.5em;">
                <h2>Settings</h2>

            </div>

            <div>
                <label class="mdc-text-field mdc-text-field--filled" id="title-input">
                    <span class="mdc-text-field__ripple"></span>
                    <input class="mdc-text-field__input" type="text" aria-labelledby="label">
                    <span id="label" class="mdc-floating-label">Title</span>
                    <span class="mdc-line-ripple"></span>
                </label>
            </div>
            <div>
                <button id="basic-switch" class="mdc-switch mdc-switch--selected" type="button" role="switch"
                    aria-checked="false" value="1">
                    <div class="mdc-switch__track"></div>
                    <div class="mdc-switch__handle-track">
                        <div class="mdc-switch__handle">
                            <div class="mdc-switch__shadow">
                                <div class="mdc-elevation-overlay"></div>
                            </div>
                            <div class="mdc-switch__ripple"></div>
                            <div class="mdc-switch__icons">
                                <svg class="mdc-switch__icon mdc-switch__icon--on" viewBox="0 0 24 24">
                                    <path d="M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z" />
                                </svg>
                                <svg class="mdc-switch__icon mdc-switch__icon--off" viewBox="0 0 24 24">
                                    <path d="M20 13H4v-2h16v2z" />
                                </svg>
                            </div>
                        </div>
                    </div>
                </button>
                <label for="basic-switch">Show Visual Media</label>
            </div>
            <div>
                <button id="knowledge-switch" class="mdc-switch mdc-switch--selected" type="button" role="switch"
                    aria-checked="true">
                    <div class="mdc-switch__track"></div>
                    <div class="mdc-switch__handle-track">
                        <div class="mdc-switch__handle">
                            <div class="mdc-switch__shadow">
                                <div class="mdc-elevation-overlay"></div>
                            </div>
                            <div class="mdc-switch__ripple"></div>
                            <div class="mdc-switch__icons">
                                <svg class="mdc-switch__icon mdc-switch__icon--on" viewBox="0 0 24 24">
                                    <path d="M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z" />
                                </svg>
                                <svg class="mdc-switch__icon mdc-switch__icon--off" viewBox="0 0 24 24">
                                    <path d="M20 13H4v-2h16v2z" />
                                </svg>
                            </div>
                        </div>
                    </div>
                </button>
                <label for="knowledge-switch">Show Knowledge</label>
            </div>
            <div>
                <button id="darkmode-switch" class="mdc-switch mdc-switch--unselected" type="button" role="switch"
                    aria-checked="true">
                    <div class="mdc-switch__track"></div>
                    <div class="mdc-switch__handle-track">
                        <div class="mdc-switch__handle">
                            <div class="mdc-switch__shadow">
                                <div class="mdc-elevation-overlay"></div>
                            </div>
                            <div class="mdc-switch__ripple"></div>
                            <div class="mdc-switch__icons">
                                <svg class="mdc-switch__icon mdc-switch__icon--on" viewBox="0 0 24 24">
                                    <path d="M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z" />
                                </svg>
                                <svg class="mdc-switch__icon mdc-switch__icon--off" viewBox="0 0 24 24">
                                    <path d="M20 13H4v-2h16v2z" />
                                </svg>
                            </div>
                        </div>
                    </div>
                </button>
                <label for="darkmode-switch">Dark Mode</label>
            </div>
            <div>
                <label for="elasticity-slider">Stiffness</label>
                <div class="mdc-slider" id="elasticity-slider">
                    <input class="mdc-slider__input" type="range" min="0" max="100" value="50" name="volume"
                        aria-label="Continuous slider demo" onchange="console.log('change',this);"
                        oninput="console.log('input',this);">
                    <div class="mdc-slider__track">
                        <div class="mdc-slider__track--inactive"></div>
                        <div class="mdc-slider__track--active">
                            <div class="mdc-slider__track--active_fill"></div>
                        </div>
                    </div>
                    <div class="mdc-slider__thumb">
                        <div class="mdc-slider__thumb-knob"></div>
                    </div>
                </div>
            </div>
            <div id="json-code-container" style="border: 1px solid gray; border-radius: 4px; display: none;">

            </div>
            <hr>
            <div>
                <h2>Share/Save</h2>
            </div>
            <div id="link-container" >
                <label for="link-text-field" style="margin-bottom: 1em; display: block;">Static Link</label>
                <div style="position: relative;">
                <label id="link-text-field" class="mdc-text-field mdc-text-field--outlined">
                    <span class="mdc-notched-outline">
                        <span class="mdc-notched-outline__leading"></span>
                        <span class="mdc-notched-outline__notch">
                        </span>
                        <span class="mdc-notched-outline__trailing"></span>
                    </span>
                    <input type="text" class="mdc-text-field__input" readonly>
                </label>

                <button id="copy-link-btn" class="mdc-button">
                    <i class="material-icons mdc-button__icon" aria-hidden="true">content_copy</i>
                </button>

                </div>
                <span >
                    <p class="help-text">
                        Copy and save the link above to continue working on the graph, store it or share it with others.<br/>
                        Please note that changing <b>anything</b> on this page will also change the link, so make sure to copy the link again after you made any changes.
                    </p>
                </span>
            </div>
            <div id="download-container">
                <label for="download-btn" style="margin-bottom: 1em; display: block;">Export Image</label>
                
      <button class="mdc-button mdc-button--raised mdc-button--icon-leading" id="download-btn" style="width:100%; padding: 2em 0em;">
        <span class="mdc-button__ripple"></span>
        <i class="material-icons material-icons-outlined mdc-button__icon" aria-hidden="true">content_paste_go</i>
        <span class="mdc-button__label">Save Image</span>
      </button>
      <span >
        <p class="help-text">
            This should either prompt you to download the image or open it in a new tab. If neither of these things work you can always press right click on the diagram and save it as an image from there.
        </p>
    </span>
            </div>
            <!-- 
  <div>

    <button class="mdc-button mdc-button--outlined mdc-button--icon-leading" id="copy-btn" onclick="copyState()">
        <span class="mdc-button__ripple"></span>
        <i class="material-icons material-icons-outlined mdc-button__icon" aria-hidden="true">content_copy</i>
        <span class="mdc-button__label">Copy</span>
      </button>
      <button class="mdc-button mdc-button--outlined mdc-button--icon-leading" id="paste-btn" onclick="pasteState()">
        <span class="mdc-button__ripple"></span>
        <i class="material-icons material-icons-outlined mdc-button__icon" aria-hidden="true">content_paste_go</i>
        <span class="mdc-button__label">Import</span>
      </button>
</div>
 -->

            <button class="mdc-button" onclick="drawer.open=false"
                style="position: absolute; right: 1em; top: 1.5em; display: inline-block;">
                <span class="mdc-button__ripple"></span>
                <i class="material-icons material-icons-outlined mdc-button__icon" aria-hidden="true">close</i>
                <span class="mdc-button__label"></span>
            </button>

        </div>
    </aside>

    <div class="mdc-drawer-scrim"></div>

    <main>
        <h1>Towards an Aesthetic of Electronic-Music Performance
            Practice
        </h1>


        <button class="mdc-button" onclick="drawer.open=true"
            style="position: fixed; left: 1em; top: 1.5em; display: inline-block;">
            <span class="mdc-button__ripple"></span>
            <i class="material-icons material-icons-outlined mdc-button__icon" aria-hidden="true">tune</i>
            <span class="mdc-button__label"></span>
        </button>

        <div id="content">
            <div id="sketch">
                <canvas id="sketch-canvas"></canvas>
            </div>
        </div>

        
        <div id="citation">see: Ciciliani, Marko. (2014). Towards an Aesthetic of Electronic-Music Performance Practice.

            <a id="dl" download href="#">Download Canvas</a>
        </div>
    </main>


<script>

const MDCSwitch = mdc.switchControl.MDCSwitch;
const MDCSlider = mdc.slider.MDCSlider;
const MDCDrawer = mdc.drawer.MDCDrawer;
const MDCList = mdc.list.MDCList;
const MDCTextField = mdc.textField.MDCTextField;
//const MDCButton = mdc.button.MDCButton;

/*
new ClipboardJS('#copy-btn', {
    text: function (trigger) {
        //return document.querySelector('#json-code-container textarea');
        return myCodeMirror.getValue();
    }
});*/
new ClipboardJS('#copy-link-btn', {
    target: function (trigger) {
        //return document.querySelector('#json-code-container textarea');
        updateShareLink();
        return linkTextField.input;
    }
});


function downloadAsImage() {
    //var dt = canvas.toDataURL('image/png');
    //this.href = dt;
    const imageFileName = "performance_analysis.png";
    if (state.settings.showKnowledge) {
        saveCanvas(imageFileName);
    } else {
        const i = get(width-800,0,800,800);
        canvasWithoutKnowledge.image(i,0,0,800,800);
        saveCanvas(canvasWithoutKnowledge, imageFileName);
    }
}
document.getElementById("dl").addEventListener("click", downloadAsImage)
document.getElementById("download-btn").addEventListener("click", downloadAsImage);


mdc.autoInit();

const linkTextField = new MDCTextField(document.getElementById("link-text-field"));

const DEFAULT_TITLE = document.querySelector('h1').textContent;
const titleTextField = new MDCTextField(document.getElementById("title-input"));
titleTextField.input.addEventListener('input', (e) => {
    const val = titleTextField.value.trim();
    if (val.length < 1) {
        document.querySelector('h1').textContent = DEFAULT_TITLE;
        delete state.settings.title;
    } else {
        console.log('title change', val);
        document.querySelector('h1').textContent = val;
        state.settings.title = val;
    }
})

let elasticityControl;
const drawer = MDCDrawer.attachTo(document.querySelector('.mdc-drawer'));
const switchControl = new MDCSwitch(document.querySelector('#basic-switch'));
document.querySelector('#basic-switch').addEventListener('click', (e) => {
    state.settings.showVisualMedia = document.querySelector('#basic-switch').ariaChecked == "true";
});
const kControl = new MDCSwitch(document.querySelector('#knowledge-switch'));
document.querySelector('#knowledge-switch').addEventListener('click', (e) => {
    state.settings.showKnowledge = document.querySelector('#knowledge-switch').ariaChecked == "true";
});
const darkControl = new MDCSwitch(document.querySelector('#darkmode-switch'));
document.querySelector('#darkmode-switch').addEventListener('click', (e) => {
    state.settings.darkMode = document.querySelector('#darkmode-switch').ariaChecked == "true";
    if (state.settings.darkMode) {
        document.body.classList.add('dark');
    } else {
        document.body.classList.remove('dark');
    }
});
//mdc.ripple.MDCRipple.attachTo(document.querySelector('#copy-btn'));
//mdc.ripple.MDCRipple.attachTo(document.querySelector('#paste-btn'));

function updateShareLink() {
    // this is still a very inefficient encoding but we should be well below the 2048 character limit for URLs still...
    const fary = new Float32Array([
        state.values.presence,
        state.values.embodiment,
        state.values.trasparency,
        state.values.freedom,
        state.values.space,
        state.values.mediation,
        state.values.camouflage,
        state.values.body,
        state.values.culturalKnowledge,
        state.values.workbasedKnowledge,

        state.visualMediaAngle,
        state.settings.elasticity,
        0, /* PLACE HOLDER FOR BOOLEAN SETTINGS */
    ]);
    let uint = new Uint8Array(fary.buffer);
    uint[uint.length - 4] = state.settings.showVisualMedia;
    uint[uint.length - 3] = state.settings.showKnowledge;
    uint[uint.length - 2] = state.settings.darkMode;
    uint[uint.length - 1] = false;
    let str = btoa(String.fromCharCode.apply(null, uint)); 
    str = encodeURIComponent(str);

    const url = window.location.href.split('?')[0]
        + '?state=' + str +
        (state.settings.title ? '&title=' + encodeURIComponent(state.settings.title) : '');
    linkTextField.foundation.setValue(url);
}

document.body.addEventListener('MDCDrawer:opened', () => {
    const elasticitySlider = document.querySelector('#elasticity-slider');
    if (!elasticityControl) {
        elasticityControl = new MDCSlider(elasticitySlider);
        elasticityControl.foundation.setValue(state.settings.elasticity * 100);
        elasticitySlider.addEventListener('MDCSlider:change', (e) => {
            state.settings.elasticity = e.detail.value / 100;
        });
    }
    updateShareLink();

    /*
    window.myCodeMirror = CodeMirror(document.getElementById("json-code-container"), {
        value: JSON.stringify(state, null, 1),
        mode: "javascript"
    });
    console.log("codeMirror", myCodeMirror);
    */

    

    //codeBlock.innerHTML = JSON.stringify(state, null, 1);
    //document.querySelector("#paste-output").textContent = 
    //hljs.highlightElement(codeBlock);
});

function decodeState() {
    const params = new URLSearchParams(window.location.search);
    const str = params.get('state');
    console.log(params);
    if (str) {
        let blob = atob(decodeURIComponent(str));
        let ary_buf = new ArrayBuffer(blob.length);
        let dv = new DataView(ary_buf);
        for (let i = 0; i < blob.length; i++) dv.setUint8(i, blob.charCodeAt(i));

        let f32_ary = new Float32Array(ary_buf);
        state.values.presence = f32_ary[0];
        state.values.embodiment = f32_ary[1];
        state.values.trasparency = f32_ary[2];
        state.values.freedom = f32_ary[3];
        state.values.space = f32_ary[4];
        state.values.mediation = f32_ary[5];
        state.values.camouflage = f32_ary[6];
        state.values.body = f32_ary[7];
        state.values.culturalKnowledge = f32_ary[8];
        state.values.workbasedKnowledge = f32_ary[9];

        if (f32_ary.length > 10) {
            state.visualMediaAngle = f32_ary[10];
            state.settings.elasticity = f32_ary[11];
            state.settings.showVisualMedia = dv.getUint8(blob.length - 4) > 0;
            switchControl.selected = state.settings.showVisualMedia;
            state.settings.showKnowledge = dv.getUint8(blob.length - 3) > 0;
            kControl.selected = state.settings.showKnowledge;
            state.settings.darkMode = dv.getUint8(blob.length - 2) > 0;
            darkControl.selected = state.settings.darkMode;
        }
    }
    const title = params.get('title');
    if (title) {
        const decodedTitle = decodeURIComponent(title);
        titleTextField.value = decodedTitle;
        document.querySelector('h1').textContent = decodedTitle;
        state.settings.title = title;
    }
    if (!state.settings.darkMode) {
        document.body.classList.remove('dark');
    }
}
window.addEventListener('DOMContentLoaded', () => {
    decodeState();
});
</script>
</body>
</html>